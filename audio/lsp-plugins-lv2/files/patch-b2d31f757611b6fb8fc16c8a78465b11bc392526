- fix of the compilation problem: https://github.com/lsp-plugins/lsp-plugin-fw/commit/b2d31f757611b6fb8fc16c8a78465b11bc392526

From b2d31f757611b6fb8fc16c8a78465b11bc392526 Mon Sep 17 00:00:00 2001
From: sadko4u <sadko4u@gmail.com>
Date: Thu, 21 Apr 2022 00:00:52 +0300
Subject: [PATCH] Fixed compilation for clang.

--- modules/lsp-plugin-fw/include/lsp-plug.in/plug-fw/wrap/jack/ports.h.orig	2022-03-25 17:27:50 UTC
+++ modules/lsp-plugin-fw/include/lsp-plug.in/plug-fw/wrap/jack/ports.h
@@ -470,7 +470,7 @@ namespace lsp
         class MeshPort: public Port
         {
             private:
-                jack::mesh_t       *pMesh;
+                plug::mesh_t       *pMesh;
 
             public:
                 explicit MeshPort(const meta::port_t *meta, Wrapper *w) : Port(meta, w)
@@ -485,7 +485,7 @@ namespace lsp
 
                 virtual int init()
                 {
-                    pMesh   = jack::mesh_t::create(pMetadata);
+                    pMesh   = jack::create_mesh(pMetadata);
                     return (pMesh == NULL) ? STATUS_NO_MEM : STATUS_OK;
                 }
 
@@ -494,7 +494,7 @@ namespace lsp
                     if (pMesh == NULL)
                         return;
 
-                    jack::mesh_t::destroy(pMesh);
+                    jack::destroy_mesh(pMesh);
                     pMesh = NULL;
                 }
 
--- modules/lsp-plugin-fw/include/lsp-plug.in/plug-fw/wrap/jack/types.h.orig	2022-03-25 17:27:50 UTC
+++ modules/lsp-plugin-fw/include/lsp-plug.in/plug-fw/wrap/jack/types.h
@@ -147,45 +147,41 @@ namespace lsp
 
         } path_t;
 
-        typedef struct mesh_t: public plug::mesh_t
+        inline plug::mesh_t *create_mesh(const meta::port_t *meta)
         {
-            static mesh_t *create(const meta::port_t *meta)
-            {
-                size_t buffers      = meta->step;
-                size_t buf_size     = meta->start * sizeof(float);
-                size_t mesh_size    = sizeof(mesh_t) + sizeof(float *) * buffers;
+            size_t buffers      = meta->step;
+            size_t buf_size     = meta->start * sizeof(float);
+            size_t mesh_size    = sizeof(plug::mesh_t) + sizeof(float *) * buffers;
 
-                // Align values to 64-byte boundaries
-                buf_size            = align_size(buf_size, OPTIMAL_ALIGN);
-                mesh_size           = align_size(mesh_size, OPTIMAL_ALIGN);
+            // Align values to 64-byte boundaries
+            buf_size            = align_size(buf_size, OPTIMAL_ALIGN);
+            mesh_size           = align_size(mesh_size, OPTIMAL_ALIGN);
 
-                // Allocate pointer
-                uint8_t *ptr        = static_cast<uint8_t *>(malloc(mesh_size + buf_size * buffers));
-                if (ptr == NULL)
-                    return NULL;
+            // Allocate pointer
+            uint8_t *ptr        = static_cast<uint8_t *>(malloc(mesh_size + buf_size * buffers));
+            if (ptr == NULL)
+                return NULL;
 
-                // Initialize references
-                mesh_t *mesh        = reinterpret_cast<mesh_t *>(ptr);
-                mesh->nState        = plug::M_EMPTY;
-                mesh->nBuffers      = 0;
-                mesh->nItems        = 0;
-                ptr                += mesh_size;
-                for (size_t i=0; i<buffers; ++i)
-                {
-                    mesh->pvData[i]    = reinterpret_cast<float *>(ptr);
-                    ptr                += buf_size;
-                }
-
-                return mesh;
-            }
-
-            static void destroy(mesh_t *mesh)
+            // Initialize references
+            plug::mesh_t *mesh  = reinterpret_cast<plug::mesh_t *>(ptr);
+            mesh->nState        = plug::M_EMPTY;
+            mesh->nBuffers      = 0;
+            mesh->nItems        = 0;
+            ptr                += mesh_size;
+            for (size_t i=0; i<buffers; ++i)
             {
-                if (mesh != NULL)
-                    free(mesh);
+                mesh->pvData[i]    = reinterpret_cast<float *>(ptr);
+                ptr                += buf_size;
             }
-        } mesh_t;
 
+            return mesh;
+        }
+
+        inline void destroy_mesh(plug::mesh_t *mesh)
+        {
+            if (mesh != NULL)
+                free(mesh);
+        }
     }
 }
 
--- modules/lsp-plugin-fw/include/lsp-plug.in/plug-fw/wrap/jack/ui_ports.h.orig	2022-03-25 17:27:50 UTC
+++ modules/lsp-plugin-fw/include/lsp-plug.in/plug-fw/wrap/jack/ui_ports.h
@@ -167,24 +167,24 @@ namespace lsp
         class UIMeshPort: public UIPort
         {
             private:
-                jack::mesh_t   *pMesh;
+                plug::mesh_t   *pMesh;
 
             public:
                 explicit UIMeshPort(jack::Port *port): UIPort(port)
                 {
-                    pMesh       = jack::mesh_t::create(port->metadata());
+                    pMesh       = jack::create_mesh(port->metadata());
                 }
 
                 virtual ~UIMeshPort()
                 {
-                    jack::mesh_t::destroy(pMesh);
+                    jack::destroy_mesh(pMesh);
                     pMesh = NULL;
                 }
 
             public:
                 virtual bool sync()
                 {
-                    mesh_t *mesh = pPort->buffer<mesh_t>();
+                    plug::mesh_t *mesh = pPort->buffer<plug::mesh_t>();
                     if ((mesh == NULL) || (!mesh->containsData()))
                         return false;
 

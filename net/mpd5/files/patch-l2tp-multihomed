Index: src/l2tp.c
===================================================================
--- src/l2tp.c	(revision 2418)
+++ src/l2tp.c	(revision 2420)
@@ -1415,9 +1415,21 @@ L2tpServerEvent(int type, void *arg)
 	tun->self_port = s->self_port;
 	tun->alive = 1;
 
-	Log(LG_PHYS, ("Incoming L2TP packet from %s %d", 
-		u_addrtoa(&tun->peer_addr, namebuf, sizeof(namebuf)), tun->peer_port));
+	if (u_addrempty(&tun->self_addr) &&
+	    !GetSockDstAddress(s->sock, &tun->self_addr))
+		Log(LG_PHYS, ("Incoming L2TP packet from %s %d",
+		    u_addrtoa(&tun->peer_addr, namebuf, sizeof(namebuf)),
+		    tun->peer_port));
+	else {
+	    char buf3[INET_ADDRSTRLEN];
 
+	    Log(LG_PHYS, ("Incoming L2TP packet from %s %d to %s %d",
+		u_addrtoa(&tun->peer_addr, namebuf, sizeof(namebuf)),
+		tun->peer_port,
+		u_addrtoa(&tun->self_addr, buf3, sizeof(buf3)),
+		tun->self_port));
+	}
+
 	/* Examine all L2TP links to get best possible fit tunnel parameters. */
 	for (k = 0; k < gNumLinks; k++) {
 		Link l2;
@@ -1552,7 +1564,7 @@ L2tpServerEvent(int type, void *arg)
 	}
 
 	/* Bind socket to a new port */
-	u_addrtosockaddr(&s->self_addr,s->self_port,&sas);
+	u_addrtosockaddr(&tun->self_addr,tun->self_port,&sas);
 	if (NgSendMsg(csock, namebuf, NGM_KSOCKET_COOKIE,
 	    NGM_KSOCKET_BIND, &sas, sas.ss_len) == -1) {
 		Perror("L2TP: bind");
@@ -1649,6 +1661,10 @@ L2tpListen(Link l)
 	    SO_REUSEPORT, &one, sizeof(one)) == -1) {
 		Perror("L2TP: setsockopt");
 		goto fail;
+	}
+	if (u_addrempty(&s->self_addr)) {
+		int on = 1;
+		setsockopt(s->sock, IPPROTO_IP, IP_RECVDSTADDR, &on, sizeof(on));
 	}
 	u_addrtosockaddr(&s->self_addr, s->self_port, &sa);
 	if (bind(s->sock, (struct sockaddr *)&sa, sa.ss_len) == -1) {
Index: src/util.c
===================================================================
--- src/util.c	(revision 2418)
+++ src/util.c	(revision 2420)
@@ -16,8 +16,9 @@
 #include <netdb.h>
 #include <tcpd.h>
 #include <sys/limits.h>
-#include <sys/wait.h>
+#include <sys/socket.h>
 #include <sys/sysctl.h>
+#include <sys/wait.h>
 #include <net/route.h>
 #include <netinet/if_ether.h>
 #include <net/ethernet.h>
@@ -1544,5 +1545,48 @@ IfaceSetFlag(const char *ifname, int value)
 		return (-1);
 	}
 	close(s);
+	return (0);
+}
+
+/*
+ * Obtain destination address of SOCK_DGRAM IPv4 UDP socket, if possible.
+ */
+int GetSockDstAddress(int sock, struct u_addr *addr)
+{
+	struct {
+		struct  msghdr msg;
+		struct	iovec iov;
+	} b;
+	union {	/* ensure correct alignment for space */
+		struct cmsghdr cm;
+		char space[CMSG_SPACE(sizeof(struct in_addr))];
+	} buf;
+
+	char	io[1024];
+	struct	cmsghdr *p;
+	ssize_t	size;
+
+	/* Sanity check */
+	if (addr->family != AF_INET)
+		return (0);
+
+	memset(&b, 0, sizeof(b));
+	b.msg.msg_iov = &b.iov;
+	b.msg.msg_iovlen = 1;
+	b.msg.msg_control = &buf;
+	b.msg.msg_controllen = sizeof(buf);
+	b.iov.iov_base = &io;
+	b.iov.iov_len = sizeof(io);
+
+	if ((size = recvmsg(sock, &b.msg, 0)) < 0) {
+		Perror("%s: recvmsg: %s", __FUNCTION__, strerror(errno));
+		return (0);
+	}
+
+	p = CMSG_FIRSTHDR(&b.msg);
+	if (p && p->cmsg_level == IPPROTO_IP && p->cmsg_type == IP_RECVDSTADDR) {
+		memcpy(&addr->u.ip4, CMSG_DATA(p), sizeof(addr->u.ip4));
+		return (1);
+	}
 	return (0);
 }
Index: src/util.h
===================================================================
--- src/util.h	(revision 2418)
+++ src/util.h	(revision 2420)
@@ -98,6 +98,7 @@ extern u_long GenerateMagic(void);
 extern int GetAnyIpAddress(struct u_addr *ipaddr, const char *ifname);
 extern int GetEther(struct u_addr *addr, struct sockaddr_dl *hwaddr);
 extern int GetPeerEther(struct u_addr *addr, struct sockaddr_dl *hwaddr);
+extern int GetSockDstAddress(int sock, struct u_addr *addr);
 extern void ppp_util_ascify(char *buf, size_t max, const char *bytes, size_t len);
 extern int IfaceSetFlag(const char *ifname, int value);
 
